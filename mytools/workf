#!/home/xxxx/anaconda3/bin/python

import os
import sys

class Base:
    def __init__(self):
        self.buffer  = {}
        self.notes   = "/home/xxxx/self/workflowy"
        self.clear_p = "/home/xxxx/anaconda3/bin/clear"
        self.vim     = "/home/xxxx/.local/bin/lvim"
        self.typora  = "/usr/bin/typora"
        self.code    = "/usr/bin/code"
        self.google  = "/usr/bin/google-chrome"

    def refresh(self, buffer = {}):
        self.buffer = {}
        self.buffer = buffer

class Note(Base):
    def __init__(self, path):
        super().__init__()
        self.finished = False
        self.exit_code = 0
        self.gdb = None
        self.notes_path = os.path.join(self.notes, path)
        self.folders = self.get_folders()
        self.pipe_flag = 0  # 0 : 默认状态; 1 : 存在管道，且目前处理第一个命令; 2 : 存在管道，中间命令；3 ：存在管道，最后一个命令

    def get_folders(self):
        folder_list = sorted(os.listdir(self.notes_path))
        folders = {}
        count = 0

        for folder in folder_list:
            if os.path.isfile(os.path.join(self.notes_path, folder)):
                if folder.find(".") != 0:
                    folders[count] = folder
                    count += 1
        return folders

    def cmd_list(self):
        for index, item in self.folders.items():
            print("{0:<3}".format(index), "{0:<3}".format("->"), item)

    def cmd_l(self):
        self.cmd_list()

    def cmd_ls(self):
        self.cmd_list()

    def cmd_search(self, key):
        buffer = {}
        if self.pipe_flag == 0:
            for index, item in self.folders.items():
                if item.count(key) == 0:
                    continue
                buffer[index] = item
                print("{0:<3}".format(index), "{0:<3}".format("->"), item)
            self.buffer = buffer
        elif self.pipe_flag == 1:
            for index, item in self.folders.items():
                if item.count(key) == 0:
                    continue
                buffer[index] = item
            self.refresh(buffer)
        else:
            for index, item in self.buffer.items():
                if item.count(key) == 0:
                    continue
                buffer[index] = item
                if self.pipe_flag == 3:
                    print("{0:<3}".format(index), "{0:<3}".format("->"), item)
            self.refresh(buffer)

    def cmd_s(self, key):
        self.cmd_search(key)

    def cmd_desc(self, key = None):
        buffer = {}
        if self.pipe_flag == 0:
            for index, item in self.folders.items():
                with open(os.path.join(self.notes_path, item), "r") as f:
                    first_line = f.readline().strip()
                buffer[index] = item
                desc_print(index, item, first_line)
            self.buffer = buffer
        elif self.pipe_flag == 1:
            for index, item in self.folders.items():
                buffer[index] = item
            self.refresh(buffer)
        else:
            for index, item in self.buffer.items():
                buffer[index] = item
                if self.pipe_flag == 3:
                    with open(os.path.join(self.notes_path, item), "r") as f:
                        first_line = f.readline().strip()
                    desc_print(index, item, first_line)
            self.refresh(buffer)

    def cmd_ag(self, key):
        cmd = f"cd {self.notes_path} && ag {key}"
        os.system(cmd)

    def cmd_vim(self, key):
        if key.isdigit():
            cmd = f"{self.vim} {self.notes_path}/{self.folders[int(key)]}"
            os.system(cmd)
        elif isinstance(key, str):
            cmd = f"{self.vim} {self.notes_path}/{key}"
            os.system(cmd)
        else:
            print("no files, please check again!")

    def cmd_v(self, key):
        self.cmd_vim(key)

    def cmd_google(self, key):
        if key.isdigit():
            cmd = f"{self.google} {self.notes_path}/{self.folders[int(key)]}"
            os.system(cmd)
        elif isinstance(key, str):
            cmd = f"{self.google} {self.notes_path}/{key}"
            os.system(cmd)
        else:
            print("no files, please check again!")

    def cmd_typora(self, key):
        if key.isdigit():
            cmd = f"{self.typora} {self.notes_path}/{self.folders[int(key)]}"
            os.system(cmd)
        elif isinstance(key, str):
            cmd = f"{self.typora} {self.notes_path}/{key}"
            os.system(cmd)
        else:
            print("no files, please check again!")

    def cmd_code(self, key):
        if key.isdigit():
            cmd = f"{self.code} {self.notes_path}/{self.folders[int(key)]}"
            os.system(cmd)
        elif isinstance(key, str):
            cmd = f"{self.code} {self.notes_path}/{key}"
            os.system(cmd)
        else:
            print("no files, please check again!")

    def cmd_delete(self, key):
        if key.isdigit():
            cmd = f"rm {self.notes_path}/{self.folders[int(key)]}"
            os.system(cmd)
            self.folders = self.get_folders()
        elif isinstance(key, str):
            cmd = f"rm {self.notes_path}/{key}"
            os.system(cmd)
            self.folders = self.get_folders()
        else:
            print("no files, please check again!")

    def cmd_del(self, key):
        self.cmd_delete(key)

    def cmd_touch(self, key):
        cmd = f"touch {self.notes_path}/{key}"
        os.system(cmd)
        self.folders = self.get_folders()

    def cmd_clear(self):
        os.system(self.clear_p)

    def cmd_help(self, cfg = None):
        if cfg is None:
            print("Documented commands (type help <topic>):")
            print("=========================================")
            print("h     l/ls  s       v     q     desc    ag    del     touch   exit")
            print("help  list  search  vim   quit  typora  code  delete  clear")
            print()
            print("Miscellaneous help topics:")
            print("===========================")
            print("exec help")
        else:
            if cfg == "l" or cfg == "ls" or cfg == "list":
                print("l(list)\n\t输出文件列表信息.")
            elif cfg == "h" or cfg == "help":
                print("h(help)\n\t帮助文档.")
            elif cfg == "s" or cfg == "search":
                print("s(search)\n\t输入关键字，在当前文件夹下检索信息.")
            elif cfg == "v" or cfg == "vim":
                print("v(vim)\n\t用vim打开当前文件.")
            elif cfg == "typora":
                print("typora\n\t用typora打开当前文件.")
            elif cfg == "code":
                print("code\n\t用vscode打开当前文件.")
            elif cfg == "desc":
                print("desc\n\t显示文件的内容的第一行信息，也就是标题信息.")
            elif cfg == "del" or cfg == "delete":
                print("del(delete)\n\t删除文件.")
            elif cfg == "touch":
                print("touch\n\t创建文件.")
            elif cfg == "clear":
                print("clear\n\t清理屏幕.")
            elif cfg == "q" or cfg == "quit":
                print("q(quit)\n\t退出.")
            elif cfg == "exit":
                print("exit\n\t直接退出.")
            else:
                print("Unknow the command.")

    def cmd_h(self, cfg = None):
        if cfg is None:
            self.cmd_help()
        else:
            self.cmd_help(cfg)

    def cmd_quit(self):
        self.exit_code = 0
        self.finished = True

    def cmd_q(self):
        self.exit_code = 0
        self.finished = True

    def cmd_exit(self):
        exit(0)

    def execute(self, cmd:str):

        array = cmd.strip().split("|")
        name  = None
        param = None

        for i in range(len(array)):
            if i == 0 and len(array) == 1:
                self.pipe_flag = 0
            elif i == 0 and len(array) != 1:
                self.pipe_flag = 1
            else:
                if i == len(array) - 1:
                    self.pipe_flag = 3
                else:
                    self.pipe_flag = 2

            cur_arr = array[i].strip().split(" ", maxsplit=1)

            if len(cur_arr) > 0:
                name = cur_arr[0].lower()

            if len(cur_arr) > 1:
                param = cur_arr[1]
            if name is None:
                return False

            if not hasattr(self, f"cmd_{name}"):
                dprint(f"Unknow command: {name}")
                return False

            method = getattr(self, f"cmd_{name}")

            args = ()
            if param is not None:
                args = param.split(" ")
            try:
                ret = method(*args)
                if (ret is None or ret) and (self.pipe_flag == 0 or self.pipe_flag == 3):
                    return True
            except Exception as e:
                dprint(e)
        return False


class NoteBooks(Base):
    def __init__(self):
        super().__init__()
        self.finished = False
        self.exit_code = 0
        self.folders = self.get_folders()

    def get_folders(self):
        folder_list = sorted(os.listdir(self.notes))
        folders = {}
        count = 0

        for folder in folder_list:
            if os.path.isdir(os.path.join(self.notes, folder)):
                if folder.find(".") != 0:
                    folders[count] = folder
                    count += 1
        return folders

    def cmd_list(self):
        for index, item in self.folders.items():
            print("\033[1;33m"  + "{0:<3}".format(index) + "\033[0m", "{0:<3}".format("->"), item);

    def cmd_l(self):
        self.cmd_list()

    def cmd_ls(self):
        self.cmd_list()

    def cmd_jump(self, key):

        if key.isdigit():
            note = Note(self.folders[int(key)])
        elif isinstance(key, str):
            note = Note(key)
        else:
            print("no folder!")

        while not note.finished:
            try:
                if key.isdigit():
                    cmd = input("\033[1;32m" + f"{self.folders[int(key)]}> " + "\033[0m")
                elif isinstance(key, str):
                    cmd = input("\033[1;32m" + f"{key}> " + "\033[0m")
                else:
                    print("no folder!")
            except KeyboardInterrupt as e:
                dprint("")
                continue
            note.execute(cmd)

        return note.exit_code

    def cmd_cd(self, key):
        self.cmd_jump(key)

    def cmd_j(self, key):
        self.cmd_jump(key)

    def cmd_delete(self, key):
        if key.isdigit():
            cmd = f"rm -r {self.notes}/{self.folders[int(key)]}"
            os.system(cmd)
            self.folders = self.get_folders()
        elif isinstance(key, str):
            cmd = f"rm -r {self.notes}/{key}"
            os.system(cmd)
            self.folders = self.get_folders()
        else:
            print("No folder, please check again!")

    def cmd_del(self, key):
        self.cmd_delete(key)

    def cmd_mkdir(self, key):
        cmd = f"mkdir {self.notes}/{key}"
        os.system(cmd)
        self.folders = self.get_folders()

    def cmd_mk(self, key):
        self.mkdir(key)

    def cmd_clear(self):
        os.system(self.clear_p)

    def cmd_help(self, cfg = None):
        if cfg is None:
            print("Documented commands (type help <topic>):")
            print("=========================================")
            print("h     j/cd    l/ls  del     mk     q     exit")
            print("help  jump    list  delete  mkdir  quit")
            print()
            print("Miscellaneous help topics:")
            print("===========================")
            print("exec help")
        else:
            if cfg == "l" or cfg == "ls" or cfg == "list":
                print("l(list)\n\t输出文件列表信息.")
            elif cfg == "cd" or cfg == "jump" or cfg == "j":
                print("j(jump) or gd\n\t跳转到指定文件夹内.")
            elif cfg == "h" or cfg == "help":
                print("h(help)\n\t帮助文档.")
            elif cfg == "del" or cfg == "delete":
                print("del(delete)\n\t删除文件.")
            elif cfg == "mkdir" or cfg == "mk":
                print("mkdir\n\t创建文件夹.")
            elif cfg == "clear":
                print("clear\n\t清理屏幕.")
            elif cfg == "q" or cfg == "quit":
                print("q(quit)\n\t退出.")
            elif cfg == "exit":
                print("exit\n\t直接退出.")
            else:
                print("Unknow the command.")

    def cmd_h(self, cfg = None):
        self.cmd_help(cfg)

    def cmd_quit(self):
        self.exit_code = 0
        self.finished = True

    def cmd_q(self):
        self.cmd_quit()

    def cmd_exit(self):
        exit(0)

    def execute(self, cmd:str):
        array = cmd.strip().split(" ", maxsplit=1)
        name  = None
        param = None

        if len(array) > 0:
            name = array[0].lower()

        if len(array) > 1:
            param = array[1]

        if name is None:
            return False
    
        if not hasattr(self, f"cmd_{name}"):
            dprint(f"Unknow command: {name}")
            return False

        method = getattr(self, f"cmd_{name}")
        args = ()
        if param is not None:
            args = param.split(" ")
        try:
            ret = method(*args)
            if ret is None or ret:
                return True
        except Exception as e:
            dprint(e)
        return False

def main():

    note = NoteBooks()

    while not note.finished:
        try:
            cmd = input("\033[1;31m" + "workflowy> " + "\033[0m")
        except KeyboardInterrupt as e:
            dprint("")
            continue
        note.execute(cmd)

    return note.exit_code

def dprint(*args, **kwargs):
    print(*args, **kwargs)

def desc_print(index, item, first_line):
    print("\033[1;33m" + "{0:<3}".format(index) + "\033[0m", "{0:<3}".format("->"), "{0:<40}".format(item), "{0:<20}".format(first_line))

if __name__ == "__main__":
    sys.exit(main())
